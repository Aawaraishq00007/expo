{"version":3,"file":"Markdown.js","sourceRoot":"","sources":["../src/Markdown.ts"],"names":[],"mappings":"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","sourcesContent":["import marked from 'marked';\nimport { unescape } from 'lodash';\n\nexport enum TokenType {\n  HEADING = 'heading',\n  LIST = 'list',\n  LIST_ITEM = 'listItem',\n  PARAGRAPH = 'paragraph',\n  TEXT = 'text',\n  BLOCKQUOTE = 'blockquote',\n  SPACE = 'space',\n  CODE = 'code',\n}\n\ntype SimpleToken<Type> = { type: Type; raw?: string };\n\nexport type TextToken<Type = TokenType.TEXT> = SimpleToken<Type> & { text: string };\n\nexport type HeadingToken = TextToken<TokenType.HEADING> & {\n  depth: number;\n  tokens: Token[];\n};\n\nexport type ListToken = SimpleToken<TokenType.LIST> & {\n  depth: number;\n  items: ListItemToken[];\n  ordered?: boolean;\n  start?: string;\n  loose?: boolean;\n};\n\nexport type ListItemToken = TextToken<TokenType.LIST_ITEM> & {\n  depth: number;\n  tokens: Token[];\n  task?: boolean;\n  checked?: boolean;\n  loose?: boolean;\n};\n\nexport type ParagraphToken = TextToken<TokenType.PARAGRAPH>;\n\nexport type SpaceToken = SimpleToken<TokenType.SPACE>;\n\nexport type CodeToken = TextToken<TokenType.CODE> & {\n  lang: string;\n};\n\nexport type BlockquoteToken = TextToken<TokenType.BLOCKQUOTE> & {\n  tokens: Token[];\n};\n\nexport type Token =\n  | HeadingToken\n  | ListToken\n  | ListItemToken\n  | ParagraphToken\n  | TextToken\n  | SpaceToken\n  | CodeToken\n  | BlockquoteToken;\n\nexport interface Tokens extends Array<Token> {\n  links?: any;\n}\n\nexport interface Renderer {\n  render(tokens: Token[]): string;\n}\n\n/**\n * Receives markdown text and returns an array of tokens.\n */\nexport function lexify(text: string): Tokens {\n  const tokens = marked.lexer(text);\n  recursivelyFixTokens(tokens);\n  return tokens;\n}\n\n/**\n * Receives an array of tokens and renders them to markdown.\n */\nexport function render(tokens: Tokens, renderer: Renderer = new MarkdownRenderer()): string {\n  // `marked` module is good enough in terms of lexifying, but its main purpose is to\n  // convert markdown to html, so we need to write our own renderer for changelogs.\n  return unescape(renderer.render(tokens).trim() + EOL);\n}\n\n/**\n * Creates heading token with given text and depth.\n */\nexport function createHeadingToken(text: string, depth: number = 1): HeadingToken {\n  return {\n    type: TokenType.HEADING,\n    depth,\n    text,\n    tokens: [createTextToken(text)],\n  };\n}\n\n/**\n * Returns a token from given text.\n */\nexport function createTextToken(text: string): TextToken {\n  return {\n    type: TokenType.TEXT,\n    text,\n  };\n}\n\nexport function createListToken(depth: number = 1): ListToken {\n  return {\n    type: TokenType.LIST,\n    depth,\n    items: [],\n  };\n}\n\nexport function createListItemToken(text: string, depth: number = 0): ListItemToken {\n  return {\n    type: TokenType.LIST_ITEM,\n    depth,\n    text,\n    tokens: [createTextToken(text)],\n  };\n}\n\n/**\n * Type guard for tokens extending TextToken.\n */\nexport function isTextToken(token: Token): token is TextToken {\n  return token.type === TokenType.TEXT;\n}\n\n/**\n * Type guard for HeadingToken type.\n */\nexport function isHeadingToken(token: Token): token is HeadingToken {\n  return token.type === TokenType.HEADING;\n}\n\n/**\n * Type guard for ListToken type.\n */\nexport function isListToken(token: Token): token is ListToken {\n  return token.type === TokenType.LIST;\n}\n\n/**\n * Type guard for ListItemToken type.\n */\nexport function isListItemToken(token: Token): token is ListItemToken {\n  return token.type === TokenType.LIST_ITEM;\n}\n\n/**\n * Indents subsequent lines in given string.\n */\nexport function indentMultilineString(str: string, depth: number = 0, indent: string = '  ') {\n  return str.replace(/\\n/g, '\\n' + indent.repeat(depth));\n}\n\n/**\n * Fixes given tokens in place. We need to know depth of the list\n */\nfunction recursivelyFixTokens(tokens: Token[], listDepth: number = 0): void {\n  for (const token of tokens) {\n    if (token.type === TokenType.LIST) {\n      token.depth = listDepth;\n\n      for (const item of token.items) {\n        item.type = TokenType.LIST_ITEM;\n        item.depth = listDepth;\n        recursivelyFixTokens(item.tokens, listDepth + 1);\n      }\n    }\n  }\n}\n\nconst EOL = '\\n';\n\nexport type RenderingContext = Partial<{\n  indent: number;\n  orderedList: boolean;\n  itemIndex: number;\n}>;\n\nexport class MarkdownRenderer implements Renderer {\n  render(tokens: Token[]): string {\n    let output = '';\n    for (const token of tokens) {\n      output += this.renderToken(token, { indent: 0 });\n    }\n    return output;\n  }\n\n  /* helpers */\n\n  renderToken(token: Token, ctx: RenderingContext): string {\n    switch (token.type) {\n      case TokenType.HEADING:\n        return this.heading(token);\n      case TokenType.LIST:\n        return this.list(token, ctx);\n      case TokenType.LIST_ITEM:\n        return this.listItem(token, ctx);\n      case TokenType.PARAGRAPH:\n        return this.paragraph(token, ctx);\n      case TokenType.TEXT:\n        return this.text(token, ctx);\n      case TokenType.SPACE:\n        return this.space(token);\n      case TokenType.CODE:\n        return this.code(token, ctx);\n      case TokenType.BLOCKQUOTE:\n        return this.blockquote(token, ctx);\n      default:\n        // `marked` provides much more tokens, however we don't need to go so deep.\n        // So far we needed only tokens with above types.\n        throw new Error(`Cannot parse token with type: ${token!.type}`);\n    }\n  }\n\n  indent(depth?: number, indentStr: string = '  '): string {\n    return depth ? indentStr.repeat(depth) : '';\n  }\n\n  /* tokens */\n\n  heading(token: HeadingToken): string {\n    return this.indent(token.depth, '#') + ' ' + token.text + EOL.repeat(2);\n  }\n\n  list(token: ListToken, ctx: { indent?: number }): string {\n    let output = '';\n    for (let i = 0; i < token.items.length; i++) {\n      output += this.listItem(token.items[i], {\n        ...ctx,\n        orderedList: token.ordered,\n        itemIndex: i + 1,\n      });\n    }\n    return output + EOL;\n  }\n\n  listItem(token: ListItemToken, ctx: RenderingContext): string {\n    const indent = ctx.indent ?? 0;\n    const bullet = ctx.orderedList ? `${ctx.itemIndex ?? 1}.` : '-';\n    let output = this.indent(indent) + bullet + ' ';\n\n    if (token.tokens[0]) {\n      output += this.renderToken(token.tokens[0], ctx).trimRight() + EOL;\n    }\n\n    for (const child of token.tokens.slice(1)) {\n      output += this.renderToken(child, { ...ctx, indent: indent + 1 }).trimRight() + EOL;\n    }\n    return output.trimRight() + EOL;\n  }\n\n  paragraph(token: ParagraphToken, ctx: RenderingContext): string {\n    return this.indent(ctx.indent) + token.text + EOL;\n  }\n\n  text(token: TextToken, ctx: RenderingContext): string {\n    // TextToken may have children which we don't really need - they would render to `text` either way.\n    return this.indent(ctx.indent) + token.text;\n  }\n\n  space(token: SpaceToken): string {\n    // Actually formatting of other tokens is good enough that we don't need to render additional newlines.\n    return EOL;\n  }\n\n  code(token: CodeToken, ctx: RenderingContext): string {\n    const lines = token.text.split(EOL);\n    const indentStr = this.indent(ctx?.indent);\n\n    lines.unshift('```' + token.lang ?? '');\n    lines.push('```');\n\n    return indentStr + lines.join(EOL + indentStr);\n  }\n\n  blockquote(token: BlockquoteToken, ctx: RenderingContext): string {\n    const indentStr = this.indent(ctx.indent);\n\n    return (\n      indentStr +\n      token.tokens\n        .map((child) => '> ' + this.renderToken(child, { ...ctx, indent: 0 }).trimRight())\n        .join(EOL + indentStr)\n    );\n  }\n}\n"]}