{"version":3,"file":"TasksRunner.js","sourceRoot":"","sources":["../src/TasksRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport chalk from 'chalk';\nimport JsonFile, { JSONObject } from '@expo/json-file';\n\nimport Git from './Git';\nimport logger from './Logger';\n\n/**\n * Descriptor of single task. Defines class members and the main function.\n */\nexport type TaskDescriptor<Args extends any[]> = {\n  /**\n   * Name of the task.\n   */\n  name: string;\n\n  /**\n   * A list of other tasks this task depends on. All these tasks will be executed before this one.\n   */\n  dependsOn?: Task<Args>[] | Task<Args>;\n\n  /**\n   * File paths to stage in the repository.\n   */\n  filesToStage?: string[] | string;\n\n  /**\n   * Task is required and thus will be run even if restored from the backup.\n   */\n  required?: boolean;\n\n  /**\n   * Whether it makes sense to save a backup after this task is completed.\n   */\n  backupable?: boolean;\n};\n\n/**\n * Handy return type for methods that might be asynchronous.\n */\ntype Promiseable<T> = T | Promise<T>;\n\n/**\n * An object that is being passed to TaskRunner constructor and provides some customization.\n */\nexport type TaskRunnerDescriptor<Args extends any[], BackupDataType = null> = {\n  tasks: Task<Args>[] | Task<Args>;\n  backupFilePath?: string | null;\n  backupExpirationTime?: number;\n  validateBackup?: (backup) => Promiseable<boolean>;\n  shouldUseBackup?: (backup) => Promiseable<boolean>;\n  restoreBackup?: (backup, ...args: Args) => Promiseable<void>;\n  createBackupData?: (task, ...args: Args) => Promiseable<BackupDataType | null>;\n  backupValidationFailed?: (backup) => void;\n  taskSucceeded?: (task: Task<Args>) => void;\n  taskFailed?: (task: Task<Args>, error: any) => void;\n};\n\n/**\n * An object that is being stored in the backup file.\n */\nexport type TasksRunnerBackup<DataType extends JSONObject | null = null> = {\n  tasks: string[];\n  resolvedTasks: string[];\n  lastTask: string;\n  timestamp: number;\n  data: DataType | null;\n};\n\n/**\n * Signature of the function is being executed as part of the task.\n */\nexport type TaskFunction<Args extends any[]> = (...args: Args) => Promise<void | symbol | Args>;\n\n/**\n * Class of error that might be thrown when running tasks.\n */\nexport class TaskError<TaskType extends { name: string }> extends Error {\n  readonly stderr?: string;\n  readonly stack?: string;\n\n  constructor(readonly task: TaskType, error: Error) {\n    super(error.message);\n    this.stderr = (error as any).stderr;\n    this.stack = error.stack;\n  }\n}\n\n/**\n * Task runner, as its name suggests, runs given task. One task can depend on other tasks\n * and the runner makes sure they all are being run. Runner also provides an easy way to\n * backup and restore tasks' state.\n */\nexport class TaskRunner<Args extends any[], BackupDataType extends JSONObject | null = null>\n  implements TaskRunnerDescriptor<Args, BackupDataType> {\n  // Descriptor properties\n  readonly tasks: Task<Args>[];\n\n  readonly backupFilePath: string | null = null;\n\n  readonly backupExpirationTime: number = 60 * 60 * 1000;\n\n  readonly validateBackup: (\n    backup: TasksRunnerBackup<BackupDataType>\n  ) => Promiseable<boolean> = () => true;\n\n  readonly shouldUseBackup: (\n    backup: TasksRunnerBackup<BackupDataType>\n  ) => Promiseable<boolean> = () => true;\n\n  readonly restoreBackup: (\n    backup: TasksRunnerBackup<BackupDataType>,\n    ...args: Args\n  ) => Promiseable<void> = () => {};\n\n  readonly createBackupData: (task, ...args: Args) => BackupDataType | null = () => null;\n\n  readonly backupValidationFailed?: (backup) => void;\n\n  readonly taskSucceeded?: (task: Task<Args>) => any;\n\n  readonly taskFailed?: (task: Task<Args>, error: Error) => any;\n\n  readonly resolvedTasks: Task<Args>[];\n\n  constructor(descriptor: TaskRunnerDescriptor<Args, BackupDataType>) {\n    const { tasks, ...rest } = descriptor;\n\n    this.tasks = ([] as Task<Args>[]).concat(tasks);\n    this.resolvedTasks = resolveTasksList(this.tasks);\n\n    Object.assign(this, rest);\n  }\n\n  /**\n   * Resolves to a boolean value determining whether the backup file exists.\n   */\n  async backupExistsAsync(): Promise<boolean> {\n    if (!this.backupFilePath) {\n      return false;\n    }\n    try {\n      await fs.access(this.backupFilePath, fs.constants.R_OK);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Returns action's backup if it exists and is still valid, `null` otherwise.\n   */\n  async getBackupAsync(): Promise<TasksRunnerBackup<BackupDataType> | null> {\n    if (!this.backupFilePath || !(await this.backupExistsAsync())) {\n      return null;\n    }\n    const backup = await JsonFile.readAsync<TasksRunnerBackup<BackupDataType>>(this.backupFilePath);\n\n    if (!(await this.isBackupValid(backup))) {\n      await this.backupValidationFailed?.(backup);\n      return null;\n    }\n    return !this.shouldUseBackup || (await this.shouldUseBackup(backup)) ? backup : null;\n  }\n\n  /**\n   * Validates backup compatibility with options passed to the command.\n   */\n  async isBackupValid(backup: TasksRunnerBackup<BackupDataType>): Promise<boolean> {\n    const tasksComparator = (a, b) => a === b.name;\n\n    if (\n      Date.now() - backup.timestamp < this.backupExpirationTime &&\n      arraysCompare(backup.resolvedTasks, this.resolvedTasks, tasksComparator) &&\n      arraysCompare(backup.tasks, this.tasks, tasksComparator)\n    ) {\n      return (await this.validateBackup?.(backup)) ?? true;\n    }\n    return false;\n  }\n\n  /**\n   * Saves backup of tasks state.\n   */\n  async saveBackup(task: Task<Args>, ...args: Args) {\n    if (!this.backupFilePath) {\n      return;\n    }\n\n    const data = await this.createBackupData(task, ...args);\n    const backup: TasksRunnerBackup<BackupDataType> = {\n      timestamp: Date.now(),\n      tasks: this.tasks.map((task) => task.name),\n      resolvedTasks: this.resolvedTasks.map((task) => task.name),\n      lastTask: task.name,\n      data,\n    };\n    await fs.outputFile(this.backupFilePath, JSON.stringify(backup, null, 2));\n  }\n\n  /**\n   * Removes backup file if specified. Must be synchronous.\n   */\n  invalidateBackup() {\n    if (this.backupFilePath) {\n      fs.removeSync(this.backupFilePath);\n    }\n  }\n\n  /**\n   * Restores backup if possible and executes tasks until they stop, throw or finish. Re-throws task errors.\n   */\n  async runAsync(...args: Args): Promise<Args> {\n    const backup = await this.getBackupAsync();\n    const startingIndex = backup\n      ? this.resolvedTasks.findIndex((task) => task.name === backup.lastTask) + 1\n      : 0;\n\n    if (backup) {\n      await this.restoreBackup(backup, ...args);\n    }\n\n    // Filter tasks to run: required ones and all those after last backup.\n    const tasks = this.resolvedTasks.filter((task, taskIndex) => {\n      return task.required || taskIndex >= startingIndex;\n    });\n\n    let nextArgs: Args = args;\n\n    for (const task of tasks) {\n      try {\n        const result = await task.taskFunction?.(...nextArgs);\n\n        // The task has stopped further tasks execution.\n        if (result === Task.STOP) {\n          break;\n        }\n        if (Array.isArray(result)) {\n          nextArgs = result;\n        }\n\n        // Stage declared files in local repository. This is also a part of the backup.\n        await Git.addFilesAsync(task.filesToStage);\n      } catch (error) {\n        // Discard unstaged changes in declared files.\n        await Git.discardFilesAsync(task.filesToStage);\n\n        this.taskFailed?.(task, error);\n        throw new TaskError<Task<Args>>(task, error);\n      }\n\n      this.taskSucceeded?.(task);\n\n      if (task.backupable) {\n        // Make a backup after each successful backupable task.\n        await this.saveBackup(task, ...args);\n      }\n    }\n\n    // If we reach here - we're done and backup should be invalidated.\n    this.invalidateBackup();\n\n    return nextArgs;\n  }\n\n  /**\n   * Same as `runAsync` but handles caught errors and calls `process.exit`.\n   */\n  async runAndExitAsync(...args: Args): Promise<void> {\n    try {\n      await this.runAsync(...args);\n      process.exit(0);\n    } catch (error) {\n      logger.error();\n\n      if (error instanceof TaskError) {\n        logger.error(`💥 Execution failed for task ${chalk.cyan(error.task.name)}.`);\n      }\n\n      logger.error('💥 Error:', error.message);\n\n      if (error.stack) {\n        const stack = error.stack.split(`${error.message}\\n`);\n        logger.debug(stack[1]);\n      }\n\n      error.stderr && logger.error('💥 stderr output:\\n', chalk.reset(error.stderr));\n      process.exit(1);\n    }\n  }\n}\n\nexport class Task<Args extends any[] = []> implements TaskDescriptor<Args> {\n  static STOP: symbol = Symbol();\n\n  readonly name: string;\n  readonly dependsOn: Task<Args>[] = [];\n  readonly filesToStage: string[] = [];\n  readonly required: boolean = false;\n  readonly backupable: boolean = true;\n  readonly taskFunction?: TaskFunction<Args>;\n\n  constructor(descriptor: TaskDescriptor<Args> | string, taskFunction?: TaskFunction<Args>) {\n    if (typeof descriptor === 'string') {\n      this.name = descriptor;\n    } else {\n      const { name, dependsOn, filesToStage, required, backupable } = descriptor;\n      this.name = name;\n      this.dependsOn = dependsOn ? ([] as Task<Args>[]).concat(dependsOn) : [];\n      this.filesToStage = filesToStage ? ([] as string[]).concat(filesToStage) : [];\n      this.required = required ?? this.required;\n      this.backupable = backupable ?? this.backupable;\n    }\n    this.taskFunction = taskFunction;\n  }\n}\n\nfunction resolveTasksList<Args extends any[]>(tasks: Task<Args>[]): Task<Args>[] {\n  const list = new Set<Task<Args>>();\n\n  function iterateThroughDependencies(task: Task<Args>) {\n    for (const dependency of task.dependsOn) {\n      iterateThroughDependencies(dependency);\n    }\n    list.add(task);\n  }\n\n  tasks.forEach((task) => iterateThroughDependencies(task));\n\n  return [...list];\n}\n\nfunction arraysCompare(arr1, arr2, comparator = (a, b) => a === b): boolean {\n  return arr1.length === arr2.length && arr1.every((item, index) => comparator(item, arr2[index]));\n}\n"]}