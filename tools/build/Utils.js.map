{"version":3,"file":"Utils.js","sourceRoot":"","sources":["../src/Utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { IOptions as GlobOptions } from 'glob';\nimport glob from 'glob-promise';\nimport chalk from 'chalk';\nimport basicSpawnAsync, { SpawnResult, SpawnOptions, SpawnPromise } from '@expo/spawn-async';\n\nimport { EXPO_DIR } from './Constants';\n\nexport { SpawnResult, SpawnOptions };\n\n/**\n * Asynchronously spawns a process with given command, args and options. Working directory is set to repo's root by default.\n */\nexport function spawnAsync(\n  command: string,\n  args: Readonly<string[]> = [],\n  options: SpawnOptions = {}\n): SpawnPromise<SpawnResult> {\n  return basicSpawnAsync(command, args, {\n    env: { ...process.env },\n    cwd: EXPO_DIR,\n    ...options,\n  });\n}\n\n/**\n * Does the same as `spawnAsync` but parses the output to JSON object.\n */\nexport async function spawnJSONCommandAsync<T = object>(\n  command: string,\n  args: Readonly<string[]> = [],\n  options: SpawnOptions = {}\n): Promise<T> {\n  const child = await spawnAsync(command, args, options);\n  try {\n    return JSON.parse(child.stdout);\n  } catch (e) {\n    e.message +=\n      '\\n' + chalk.red('Cannot parse this output as JSON: ') + chalk.yellow(child.stdout.trim());\n    throw e;\n  }\n}\n\n/**\n * Deeply clones an object. It's used to make a backup of home's `app.json` file.\n */\nexport function deepCloneObject<ObjectType extends object = object>(\n  object: ObjectType\n): ObjectType {\n  return JSON.parse(JSON.stringify(object));\n}\n\n/**\n * Waits given amount of time (in milliseconds).\n */\nexport function sleepAsync(duration: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, duration);\n  });\n}\n\n/**\n * Filters an array asynchronously.\n */\nexport async function filterAsync<T = any>(\n  arr: T[],\n  filter: (item: T, index: number) => boolean | Promise<boolean>\n): Promise<T[]> {\n  const results = await Promise.all(arr.map(filter));\n  return arr.filter((item, index) => results[index]);\n}\n\n/**\n * Retries executing the function with given interval and with given retry limit.\n * It resolves immediately once the callback returns anything else than `undefined`.\n */\nexport async function retryAsync<T = any>(\n  interval: number,\n  limit: number,\n  callback: () => T | Promise<T>\n): Promise<T> {\n  return new Promise((resolve) => {\n    let count = 0;\n\n    const timeoutCallback = async () => {\n      const result = await callback();\n\n      if (result !== undefined) {\n        resolve(result);\n        return;\n      }\n      if (++count < limit) {\n        setTimeout(timeoutCallback, interval);\n      } else {\n        resolve(undefined);\n      }\n    };\n    timeoutCallback();\n  });\n}\n\n/**\n * Executes regular expression against a string until the last match is found.\n */\nexport function execAll(rgx: RegExp, str: string, index: number = 0): string[] {\n  const globalRgx = new RegExp(rgx.source, 'g' + rgx.flags.replace('g', ''));\n  const matches: string[] = [];\n  let match;\n  while ((match = globalRgx.exec(str))) {\n    matches.push(match[index]);\n  }\n  return matches;\n}\n\n/**\n * Searches for files matching given glob patterns.\n */\nexport async function searchFilesAsync(\n  rootPath: string,\n  patterns: string | string[],\n  options?: GlobOptions\n): Promise<Set<string>> {\n  const files = await Promise.all(\n    arrayize(patterns).map((pattern) =>\n      glob(pattern, {\n        cwd: rootPath,\n        nodir: true,\n        ...options,\n      })\n    )\n  );\n  return new Set(([] as string[]).concat(...files));\n}\n\n/**\n * Ensures the value is an array.\n */\nexport function arrayize<T>(value: T | T[]): T[] {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return value != null ? [value] : [];\n}\n"]}