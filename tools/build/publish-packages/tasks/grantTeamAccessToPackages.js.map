{"version":3,"file":"grantTeamAccessToPackages.js","sourceRoot":"","sources":["../../../src/publish-packages/tasks/grantTeamAccessToPackages.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kDAA0B;AAE1B,0DAAkC;AAClC,+CAAiC;AACjC,mDAAyC;AAEzC,qDAAkD;AAElD,MAAM,EAAE,KAAK,EAAE,GAAG,eAAK,CAAC;AAExB;;;GAGG;AACU,QAAA,yBAAyB,GAAG,IAAI,kBAAI,CAC/C;IACE,IAAI,EAAE,2BAA2B;IACjC,SAAS,EAAE,CAAC,+BAAc,CAAC;CAC5B,EACD,KAAK,EAAE,OAAiB,EAAE,OAAuB,EAAE,EAAE;IACnD,mFAAmF;IACnF,mFAAmF;IACnF,4CAA4C;IAC5C,MAAM,WAAW,GAAG,MAAM,GAAG,CAAC,mBAAmB,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAC;IACjF,MAAM,qBAAqB,GAAG,OAAO;SAClC,MAAM,CAAC,2BAA2B,CAAC,WAAW,CAAC,CAAC;SAChD,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAErC,IAAI,qBAAqB,CAAC,MAAM,KAAK,CAAC,EAAE;QACtC,gBAAM,CAAC,OAAO,CAAC,0CAA0C,CAAC,CAAC;QAC3D,OAAO;KACR;IAED,gBAAM,CAAC,IAAI,CACT,SAAS,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,iCAAiC,CAAC,CAAC,CAAC,yBAAyB,EAAE,EACtF,qBAAqB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAC3D,CAAC;IAEF,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE;QAChB,KAAK,MAAM,WAAW,IAAI,qBAAqB,EAAE;YAC/C,IAAI;gBACF,MAAM,GAAG,CAAC,yBAAyB,CAAC,WAAW,EAAE,GAAG,CAAC,yBAAyB,CAAC,CAAC;aACjF;YAAC,OAAO,CAAC,EAAE;gBACV,gBAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;gBACnC,gBAAM,CAAC,KAAK,CAAC,0BAA0B,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;aACrE;SACF;KACF;AACH,CAAC,CACF,CAAC;AAEF;;GAEG;AACH,SAAS,2BAA2B,CAAC,WAAqB;IACxD,OAAO,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,CAC5B,CAAC,OAAO,IAAI,KAAK,CAAC,SAAS,CAAC,IAAI,gCAAgC,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;AAC3F,CAAC;AAED;;GAEG;AACH,SAAS,gCAAgC,CACvC,KAAe,EACf,OAAoC;IAEpC,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO,IAAI,CAAC;KACb;IACD,8GAA8G;IAC9G,MAAM,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CACzD,UAAU,CAAC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC,CACvC,CAAC;IACF,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;AAC3D,CAAC","sourcesContent":["import chalk from 'chalk';\n\nimport logger from '../../Logger';\nimport * as Npm from '../../Npm';\nimport { Task } from '../../TasksRunner';\nimport { CommandOptions, Parcel, TaskArgs } from '../types';\nimport { prepareParcels } from './prepareParcels';\n\nconst { green } = chalk;\n\n/**\n * Grants package access to the whole team. Applies only when the package\n * wasn't published before or someone from the team is not included in maintainers list.\n */\nexport const grantTeamAccessToPackages = new Task<TaskArgs>(\n  {\n    name: 'grantTeamAccessToPackages',\n    dependsOn: [prepareParcels],\n  },\n  async (parcels: Parcel[], options: CommandOptions) => {\n    // There is no good way to check whether the package is added to organization team,\n    // so let's get all team members and check if they all are declared as maintainers.\n    // If they don't, grant access for the team.\n    const teamMembers = await Npm.getTeamMembersAsync(Npm.EXPO_DEVELOPERS_TEAM_NAME);\n    const packagesToGrantAccess = parcels\n      .filter(filterPackagesToGrantAccess(teamMembers))\n      .map(({ pkg }) => pkg.packageName);\n\n    if (packagesToGrantAccess.length === 0) {\n      logger.success('\\nðŸŽ–  Granting team access not required.');\n      return;\n    }\n\n    logger.info(\n      `\\nðŸŽ–  ${options.dry ? 'Team access would be granted to' : 'Granting team access to'}`,\n      packagesToGrantAccess.map((name) => green(name)).join(' ')\n    );\n\n    if (!options.dry) {\n      for (const packageName of packagesToGrantAccess) {\n        try {\n          await Npm.grantReadWriteAccessAsync(packageName, Npm.EXPO_DEVELOPERS_TEAM_NAME);\n        } catch (e) {\n          logger.debug(e.stderr || e.stdout);\n          logger.error(`ðŸŽ–  Granting access to ${green(packageName)} failed`);\n        }\n      }\n    }\n  }\n);\n\n/**\n * Returns filter function that when called returns a boolean whether to grant access or not.\n */\nfunction filterPackagesToGrantAccess(teamMembers: string[]) {\n  return ({ pkgView, state }) =>\n    (pkgView || state.published) && doesSomeoneHaveNoAccessToPackage(teamMembers, pkgView);\n}\n\n/**\n * Returns boolean value determining if someone from given users list is not a maintainer of the package.\n */\nfunction doesSomeoneHaveNoAccessToPackage(\n  users: string[],\n  pkgView?: Npm.PackageViewType | null\n): boolean {\n  if (!pkgView) {\n    return true;\n  }\n  // Maintainers array has items of shape: \"username <user@domain.com>\" so we strip everything after whitespace.\n  const maintainers = pkgView.maintainers.map((maintainer) =>\n    maintainer.replace(/^(.+)\\s.*$/, '$1')\n  );\n  return users.some((user) => !maintainers.includes(user));\n}\n"]}