{"version":3,"file":"findUnpublished.js","sourceRoot":"","sources":["../../../src/publish-packages/tasks/findUnpublished.ts"],"names":[],"mappings":"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","sourcesContent":["import npmPacklist from 'npm-packlist';\n\nimport * as Changelogs from '../../Changelogs';\nimport { GitDirectory, GitFileLog, GitFileStatus } from '../../Git';\nimport logger from '../../Logger';\nimport { Task } from '../../TasksRunner';\nimport { filterAsync } from '../../Utils';\nimport { prepareParcels } from './prepareParcels';\nimport { CommandOptions, Parcel, PackageGitLogs, TaskArgs, ReleaseType } from '../types';\n\n/**\n * An array of directories treated as containing native code.\n */\nconst NATIVE_DIRECTORIES = ['ios', 'android', 'cpp'];\n\n/**\n * Finds unpublished packages. Package is considered unpublished if there are\n * any new commits or changelog entries prior to previous publish on the current branch.\n */\nexport const findUnpublished = new Task<TaskArgs>(\n  {\n    name: 'findUnpublished',\n    dependsOn: [prepareParcels],\n  },\n  async (parcels: Parcel[], options: CommandOptions): Promise<void | symbol | TaskArgs> => {\n    logger.info('\\nðŸ‘€ Searching for packages with unpublished changes...');\n\n    const newParcels = await filterAsync(parcels, async (parcel) => {\n      const { pkgView, changelog, gitDir, state } = parcel;\n      const changelogChanges = await changelog.getChangesAsync();\n      const logs = await getPackageGitLogsAsync(gitDir, pkgView?.gitHead);\n\n      state.logs = logs;\n      state.changelogChanges = changelogChanges;\n      state.minReleaseType = await getMinReleaseTypeAsync(parcel);\n\n      // Return whether the package has any unpublished changes or git logs couldn't be obtained.\n      return !logs || logs.files.length > 0 || changelogChanges.totalCount > 0;\n    });\n\n    if (newParcels.length === 0) {\n      logger.success('\\nâœ… All packages are up-to-date.');\n      return Task.STOP;\n    }\n    return [newParcels, options];\n  }\n);\n\n/**\n * Gets lists of commits and files changed under given directory and since commit with given checksum.\n * Returned files list is filtered out from files ignored by npm when it creates package's tarball.\n * Can return `null` if given commit is not an ancestor of head commit.\n */\nasync function getPackageGitLogsAsync(\n  gitDir: GitDirectory,\n  fromCommit?: string\n): Promise<PackageGitLogs> {\n  if (!fromCommit || !(await gitDir.isAncestorAsync(fromCommit))) {\n    return null;\n  }\n\n  const commits = await gitDir.logAsync({\n    fromCommit,\n    toCommit: 'head',\n  });\n\n  const gitFiles = await gitDir.logFilesAsync({\n    fromCommit,\n    toCommit: commits[0]?.hash,\n  });\n\n  // Get an array of relative paths to files that will be shipped with the package.\n  const packlist = await npmPacklist({ path: gitDir.path });\n\n  // Filter git files to contain only deleted or \"packlisted\" files.\n  const files = gitFiles.filter(\n    (file) => file.status === GitFileStatus.D || packlist.includes(file.relativePath)\n  );\n\n  return {\n    commits,\n    files,\n  };\n}\n\n/**\n * Returns minimum release type for given parcel (doesn't take dependencies into account).\n */\nasync function getMinReleaseTypeAsync(parcel: Parcel): Promise<ReleaseType> {\n  const { logs, changelogChanges } = parcel.state;\n\n  const unpublishedChanges = changelogChanges?.versions[Changelogs.UNPUBLISHED_VERSION_NAME];\n  const hasBreakingChanges = unpublishedChanges?.[Changelogs.ChangeType.BREAKING_CHANGES]?.length;\n  const hasNewFeatures = unpublishedChanges?.[Changelogs.ChangeType.NEW_FEATURES]?.length;\n\n  // For breaking changes and new features we follow semver.\n  if (hasBreakingChanges) {\n    return ReleaseType.MAJOR;\n  }\n  if (hasNewFeatures) {\n    return ReleaseType.MINOR;\n  }\n\n  // If the package is a native module, then we have to check whether there are any native changes.\n  if (await parcel.pkg.isNativeModuleAsync()) {\n    const hasNativeChanges = logs && fileLogsContainNativeChanges(logs.files);\n    return hasNativeChanges ? ReleaseType.MINOR : ReleaseType.PATCH;\n  }\n\n  return ReleaseType.PATCH;\n}\n\n/**\n * Determines whether git file logs contain any changes in directories with native code.\n */\nfunction fileLogsContainNativeChanges(fileLogs: GitFileLog[]): boolean {\n  return fileLogs.some((fileLog) => {\n    return NATIVE_DIRECTORIES.some((dir) => fileLog.relativePath.startsWith(`${dir}/`));\n  });\n}\n"]}