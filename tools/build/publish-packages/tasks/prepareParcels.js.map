{"version":3,"file":"prepareParcels.js","sourceRoot":"","sources":["../../../src/publish-packages/tasks/prepareParcels.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\n\nimport logger from '../../Logger';\nimport Git from '../../Git';\nimport * as Changelogs from '../../Changelogs';\nimport { Package, getListOfPackagesAsync } from '../../Packages';\nimport { Task } from '../../TasksRunner';\nimport { CommandOptions, Parcel, TaskArgs } from '../types';\n\nconst { green } = chalk;\n\n/**\n * Gets a list of public packages in the monorepo, downloads `npm view` result of them,\n * creates their Changelog instance and fills in given parcels array (it's empty at the beginning).\n */\nexport const prepareParcels = new Task<TaskArgs>(\n  {\n    name: 'prepareParcels',\n  },\n  async (parcels: Parcel[], options: CommandOptions) => {\n    logger.info('ðŸ”Ž Gathering data about packages...');\n\n    const { packageNames } = options;\n    const allPackages = await getListOfPackagesAsync();\n    const allPackagesObj = allPackages.reduce((acc, pkg) => {\n      acc[pkg.packageName] = pkg;\n      return acc;\n    }, {});\n\n    // Verify that provided package names are valid.\n    for (const packageName of packageNames) {\n      if (!allPackagesObj[packageName]) {\n        throw new Error(`Package with provided name ${green(packageName)} does not exist.`);\n      }\n    }\n\n    const filteredPackages = allPackages.filter((pkg) => {\n      const isPrivate = pkg.packageJson.private;\n      const isIncluded = packageNames.length === 0 || packageNames.includes(pkg.packageName);\n      return !isPrivate && isIncluded;\n    });\n\n    parcels.push(...(await Promise.all(filteredPackages.map(createParcelAsync))));\n\n    if (packageNames.length > 0) {\n      // Even if some packages have been explicitly listed as command arguments,\n      // we also must take their dependencies into account.\n\n      const parcelsObj = parcels.reduce((acc, parcel) => {\n        acc[parcel.pkg.packageName] = parcel;\n        return acc;\n      }, {});\n\n      await recursivelyResolveDependenciesAsync(allPackagesObj, parcelsObj, parcels);\n    }\n  }\n);\n\n/**\n * Wraps `Package` object into a parcels - convenient wrapper providing more package-related helpers.\n */\nexport async function createParcelAsync(pkg: Package): Promise<Parcel> {\n  const pkgView = await pkg.getPackageViewAsync();\n  const changelog = Changelogs.loadFrom(pkg.changelogPath);\n  const gitDir = new Git.Directory(pkg.path);\n\n  return {\n    pkg,\n    pkgView,\n    changelog,\n    gitDir,\n    dependents: [],\n    dependencies: [],\n    state: {},\n  };\n}\n\n/**\n * Recursively resolves dependencies for every chosen package.\n */\nasync function recursivelyResolveDependenciesAsync(\n  allPackagesObject: { [key: string]: Package },\n  parcelsObject: { [key: string]: Parcel },\n  parcels: Parcel[]\n): Promise<void> {\n  const newParcels: Parcel[] = [];\n\n  for (const parcel of parcels) {\n    const dependencies = parcel.pkg.getDependencies().filter((dependency) => {\n      return (\n        dependency.versionRange !== '*' &&\n        allPackagesObject[dependency.name] &&\n        !parcelsObject[dependency.name]\n      );\n    });\n\n    await Promise.all(\n      dependencies.map(async ({ name }) => {\n        const dependencyPkg = allPackagesObject[name];\n        let dependencyParcel = parcelsObject[name];\n\n        // If a parcel for this dependency doesn't exist yet, let's create it.\n        if (!dependencyParcel) {\n          dependencyParcel = await createParcelAsync(dependencyPkg);\n          parcelsObject[name] = dependencyParcel;\n          newParcels.push(dependencyParcel);\n        }\n\n        dependencyParcel.dependents.push(parcel);\n        parcel.dependencies.push(dependencyParcel);\n      })\n    );\n  }\n\n  if (newParcels.length > 0) {\n    await recursivelyResolveDependenciesAsync(allPackagesObject, parcelsObject, newParcels);\n    parcels.push(...newParcels);\n  }\n}\n"]}