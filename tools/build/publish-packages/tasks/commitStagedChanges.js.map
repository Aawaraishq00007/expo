{"version":3,"file":"commitStagedChanges.js","sourceRoot":"","sources":["../../../src/publish-packages/tasks/commitStagedChanges.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAE1B,oDAA4B;AAC5B,0DAAkC;AAClC,mDAAyC;AAEzC,iFAA8E;AAE9E,MAAM,EAAE,IAAI,EAAE,GAAG,eAAK,CAAC;AAEvB;;GAEG;AACU,QAAA,mBAAmB,GAAG,IAAI,kBAAI,CACzC;IACE,IAAI,EAAE,qBAAqB;IAC3B,SAAS,EAAE,CAAC,2DAA4B,CAAC;CAC1C,EACD,KAAK,EAAE,OAAiB,EAAE,OAAuB,EAAE,EAAE;IACnD,MAAM,WAAW,GAAG,MAAM,aAAG,CAAC,mBAAmB,EAAE,CAAC;IAEpD,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;QAC5B,0FAA0F;QAC1F,uFAAuF;QACvF,yDAAyD;QACzD,gBAAM,CAAC,IAAI,CAAC,sEAAsE,CAAC,CAAC;QACpF,OAAO;KACR;IAED,MAAM,aAAa,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;IACvD,MAAM,iBAAiB,GAAG,OAAO;SAC9B,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,WAAW,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;SACrE,IAAI,CAAC,IAAI,CAAC,CAAC;IAEd,gBAAM,CAAC,IAAI,CAAC,yCAAyC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;IAE5E,MAAM,aAAG,CAAC,WAAW,CAAC;QACpB,KAAK,EAAE,aAAa;QACpB,IAAI,EAAE,iBAAiB;KACxB,CAAC,CAAC;AACL,CAAC,CACF,CAAC;AAEF;;;GAGG;AACH,SAAS,uBAAuB,CAAC,OAAuB;IACtD,IAAI,OAAO,CAAC,aAAa,EAAE;QACzB,OAAO,OAAO,CAAC,aAAa,CAAC;KAC9B;IACD,IAAI,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,MAAM,IAAI,OAAO,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;QACtE,OAAO,WAAW,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;KACrD;IACD,OAAO,kBAAkB,CAAC;AAC5B,CAAC","sourcesContent":["import chalk from 'chalk';\n\nimport Git from '../../Git';\nimport logger from '../../Logger';\nimport { Task } from '../../TasksRunner';\nimport { CommandOptions, Parcel, TaskArgs } from '../types';\nimport { resolveReleaseTypeAndVersion } from './resolveReleaseTypeAndVersion';\n\nconst { blue } = chalk;\n\n/**\n * Commits staged changes made by all previous tasks.\n */\nexport const commitStagedChanges = new Task<TaskArgs>(\n  {\n    name: 'commitStagedChanges',\n    dependsOn: [resolveReleaseTypeAndVersion],\n  },\n  async (parcels: Parcel[], options: CommandOptions) => {\n    const stagedFiles = await Git.getStagedFilesAsync();\n\n    if (stagedFiles.length === 0) {\n      // This may happen if versions have already been updated â€” manually or by previous publish\n      // that failed after committing and pushing to remote. It's safe to just skip this step\n      // and use the current head commit as the publish commit.\n      logger.info(`\\nðŸ“¼ Nothing to commit â€” using previous commit as the publish commit`);\n      return;\n    }\n\n    const commitMessage = commitMessageForOptions(options);\n    const commitDescription = parcels\n      .map(({ pkg, state }) => `${pkg.packageName}@${state.releaseVersion}`)\n      .join('\\n');\n\n    logger.info(`\\nðŸ“¼ Committing changes with message: ${blue(commitMessage)}`);\n\n    await Git.commitAsync({\n      title: commitMessage,\n      body: commitDescription,\n    });\n  }\n);\n\n/**\n * If commit message was provided as an option then it's returned.\n * Otherwise it is auto-generated based on provided package names.\n */\nfunction commitMessageForOptions(options: CommandOptions): string {\n  if (options.commitMessage) {\n    return options.commitMessage;\n  }\n  if (0 < options.packageNames.length && options.packageNames.length < 4) {\n    return `Publish ${options.packageNames.join(', ')}`;\n  }\n  return 'Publish packages';\n}\n"]}