{"version":3,"file":"cutOffChangelogs.js","sourceRoot":"","sources":["../../../src/publish-packages/tasks/cutOffChangelogs.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAE1B,0DAAkC;AAClC,mDAAyC;AAEzC,iFAA8E;AAE9E,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,eAAK,CAAC;AAE9B;;;GAGG;AACU,QAAA,gBAAgB,GAAG,IAAI,kBAAI,CACtC;IACE,IAAI,EAAE,kBAAkB;IACxB,SAAS,EAAE,CAAC,2DAA4B,CAAC;IACzC,YAAY,EAAE,CAAC,0BAA0B,CAAC;CAC3C,EACD,KAAK,EAAE,OAAiB,EAAE,EAAE;IAC1B,gBAAM,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;IAE/C,MAAM,OAAO,CAAC,GAAG,CACf,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE;QAC9C,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;YACzB,OAAO;SACR;QAED,IAAI,UAAU,GAAG,EAAE,CAAC;QAEpB,IAAI,MAAM,SAAS,CAAC,eAAe,EAAE,EAAE;YACrC,MAAM,QAAQ,GAAG,MAAM,SAAS,CAAC,gBAAgB,EAAE,CAAC;YAEpD,+EAA+E;YAC/E,wGAAwG;YACxG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;gBAC5C,gBAAM,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC,CAAC;gBACjD,MAAM,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;gBAClD,MAAM,SAAS,CAAC,SAAS,EAAE,CAAC;gBAC5B,OAAO;aACR;YACD,UAAU,GAAG,wBAAwB,CAAC;SACvC;aAAM;YACL,UAAU,GAAG,mBAAmB,CAAC;SAClC;QACD,gBAAM,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,cAAc,UAAU,EAAE,CAAC,CAAC,CAAC;IAC7E,CAAC,CAAC,CACH,CAAC;AACJ,CAAC,CACF,CAAC","sourcesContent":["import chalk from 'chalk';\n\nimport logger from '../../Logger';\nimport { Task } from '../../TasksRunner';\nimport { Parcel, TaskArgs } from '../types';\nimport { resolveReleaseTypeAndVersion } from './resolveReleaseTypeAndVersion';\n\nconst { green, gray } = chalk;\n\n/**\n * Cuts off changelogs - renames unpublished section header\n * to the new version and adds new unpublished section on top.\n */\nexport const cutOffChangelogs = new Task<TaskArgs>(\n  {\n    name: 'cutOffChangelogs',\n    dependsOn: [resolveReleaseTypeAndVersion],\n    filesToStage: ['packages/**/CHANGELOG.md'],\n  },\n  async (parcels: Parcel[]) => {\n    logger.info('\\n✂️  Cutting off changelogs...');\n\n    await Promise.all(\n      parcels.map(async ({ pkg, changelog, state }) => {\n        if (!state.releaseVersion) {\n          return;\n        }\n\n        let skipReason = '';\n\n        if (await changelog.fileExistsAsync()) {\n          const versions = await changelog.getVersionsAsync();\n\n          // This prevents unnecessary cut-offs when that version was already cutted off.\n          // Maybe we should move \"unpublished\" entries to this version? It's probably too rare to worry about it.\n          if (!versions.includes(state.releaseVersion)) {\n            logger.log('  ', green(pkg.packageName) + '...');\n            await changelog.cutOffAsync(state.releaseVersion);\n            await changelog.saveAsync();\n            return;\n          }\n          skipReason = 'version already exists';\n        } else {\n          skipReason = 'no changelog file';\n        }\n        logger.log('  ', green(pkg.packageName), gray(`- skipped, ${skipReason}`));\n      })\n    );\n  }\n);\n"]}