{"version":3,"file":"MergeChangelogs.js","sourceRoot":"","sources":["../../src/commands/MergeChangelogs.ts"],"names":[],"mappings":"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","sourcesContent":["import { Command } from '@expo/commander';\nimport JsonFile from '@expo/json-file';\nimport chalk from 'chalk';\nimport path from 'path';\nimport inquirer from 'inquirer';\nimport semver from 'semver';\n\nimport {\n  Changelog,\n  ChangelogChanges,\n  ChangelogEntry,\n  ChangeType,\n  UNPUBLISHED_VERSION_NAME,\n} from '../Changelogs';\nimport { EXPO_DIR } from '../Constants';\nimport { stripNonAsciiChars, formatChangelogEntry } from '../Formatter';\nimport logger from '../Logger';\nimport { getListOfPackagesAsync, Package } from '../Packages';\nimport { filterAsync } from '../Utils';\n\nconst MAIN_CHANGELOG_PATH = path.join(EXPO_DIR, 'CHANGELOG.md');\nconst VERSIONS_FILE_PATH = path.join(EXPO_DIR, 'changelogVersions.json');\n\ntype CommandOptions = {\n  cutOff: boolean;\n};\n\ntype ChangesMap = Map<Package, ChangelogChanges['versions']>;\ntype ChangelogVersions = Record<string, Record<string, string>>;\n\nexport default (program: Command) => {\n  program\n    .command('merge-changelogs')\n    .alias('mc')\n    .description('Merges packages changelogs into the root one.')\n    .option(\n      '-c, --cut-off',\n      'Whether to cut off SDK changelog after merging. Works only without --sdk flag.'\n    )\n    .asyncAction(async (options: CommandOptions) => {\n      const mainChangelog = new Changelog(MAIN_CHANGELOG_PATH);\n      const changesMap: ChangesMap = new Map();\n      const versions = await JsonFile.readAsync<ChangelogVersions>(VERSIONS_FILE_PATH);\n      const previousVersion = await mainChangelog.getLastPublishedVersionAsync();\n      const nextVersion = semver.inc(previousVersion, 'major');\n\n      if (!previousVersion) {\n        throw new Error('Cannot find last published version in SDK changelog.');\n      }\n\n      // Versions object will be used to do cut-off. Make a new field for the next SDK in advance.\n      versions[nextVersion] = { ...versions[previousVersion] };\n\n      logger.info('\\n🤏 Getting a list of packages...');\n\n      // Get public packages that are not explicitly set to `null` in `changelogVersions.json`.\n      const packages = await filterAsync(await getListOfPackagesAsync(), async (pkg) => {\n        return (\n          !pkg.packageJson.private &&\n          versions[previousVersion]?.[pkg.packageName] !== null &&\n          (await pkg.hasChangelogAsync())\n        );\n      });\n\n      // Load changes into `changesMap`.\n      await getChangesFromPackagesAsync(packages, changesMap, versions, previousVersion);\n\n      // Insert entries for packages not bundled in previous SDK.\n      await insertInitialReleasesAsync(\n        mainChangelog,\n        changesMap,\n        versions,\n        previousVersion,\n        nextVersion\n      );\n\n      // Insert updates from previously bundled packages.\n      await insertNewChangelogEntriesAsync(\n        mainChangelog,\n        changesMap,\n        versions,\n        previousVersion,\n        nextVersion\n      );\n\n      if (options.cutOff) {\n        await cutOffMainChangelogAsync(mainChangelog, versions, nextVersion);\n      }\n\n      logger.info('\\n💾 Saving SDK changelog...');\n\n      await mainChangelog.saveAsync();\n\n      logger.success('\\n✅ Successfully merged changelog entries.');\n    });\n};\n\n/**\n * Gets changes in packages changelogs as of the version bundled in previous SDK version.\n */\nasync function getChangesFromPackagesAsync(\n  packages: Package[],\n  changesMap: ChangesMap,\n  versions: ChangelogVersions,\n  previousVersion: string\n): Promise<void> {\n  logger.info('\\n🔍 Gathering changelog entries from packages...');\n\n  await Promise.all(\n    packages.map(async (pkg) => {\n      const changelog = new Changelog(pkg.changelogPath);\n      const fromVersion = versions[previousVersion]?.[pkg.packageName];\n      const changes = await changelog.getChangesAsync(fromVersion);\n\n      if (changes.totalCount > 0) {\n        changesMap.set(pkg, changes.versions);\n      }\n    })\n  );\n}\n\n/**\n * Inserts initial package releases at the beginning of new features.\n */\nasync function insertInitialReleasesAsync(\n  mainChangelog: Changelog,\n  changesMap: ChangesMap,\n  versions: ChangelogVersions,\n  previousVersion: string,\n  nextVersion: string\n): Promise<void> {\n  for (const pkg of changesMap.keys()) {\n    // Get version of the package in previous SDK.\n    const fromVersion = versions[previousVersion]?.[pkg.packageName];\n\n    // The package wasn't bundled in SDK yet.\n    if (!fromVersion) {\n      // Delete the package from the map, no need to handle them again in further functions.\n      changesMap.delete(pkg);\n\n      if (!(await promptToMakeInitialReleaseAsync(pkg.packageName))) {\n        continue;\n      }\n\n      // Update versions object with the local version.\n      versions[nextVersion][pkg.packageName] = pkg.packageVersion;\n\n      // Unshift initial release entry instead of grouped entries.\n      await mainChangelog.insertEntriesAsync(\n        UNPUBLISHED_VERSION_NAME,\n        ChangeType.NEW_FEATURES,\n        null,\n        [`Initial release of **\\`${pkg.packageName}\\`** 🥳`],\n        {\n          unshift: true,\n        }\n      );\n      logger.info(`\\n📦 Inserted initial release of ${chalk.green(pkg.packageName)}`);\n    }\n  }\n}\n\n/**\n * Inserts new changelog entries made as of previous SDK.\n */\nasync function insertNewChangelogEntriesAsync(\n  mainChangelog: Changelog,\n  changesMap: ChangesMap,\n  versions: ChangelogVersions,\n  previousVersion: string,\n  nextVersion: string\n): Promise<void> {\n  for (const [pkg, changes] of changesMap) {\n    // Sort versions so we keep the order of changelog entries from oldest to newest.\n    const packageVersions = Object.keys(changes).sort(sortVersionsAsc);\n\n    // Get version of the package in previous SDK.\n    const fromVersion = versions[previousVersion]?.[pkg.packageName];\n\n    // Update versions object with the local version.\n    versions[nextVersion][pkg.packageName] = pkg.packageVersion;\n\n    const insertedEntries: Record<string, ChangelogEntry[]> = {};\n    let entriesCount = 0;\n\n    for (const packageVersion of packageVersions) {\n      for (const type in changes[packageVersion]) {\n        const entries = await mainChangelog.insertEntriesAsync(\n          UNPUBLISHED_VERSION_NAME,\n          type,\n          pkg.packageName,\n          changes[packageVersion][type]\n        );\n\n        if (entries.length > 0) {\n          insertedEntries[type] = entries;\n          entriesCount += entries.length;\n        }\n      }\n    }\n\n    if (entriesCount === 0) {\n      continue;\n    }\n\n    // Package was already bundled within previous version.\n    logger.info(\n      `\\n📦 Inserted ${chalk.green(pkg.packageName)} entries as of ${chalk.yellow(fromVersion)}`\n    );\n\n    for (const [type, entries] of Object.entries(insertedEntries)) {\n      logger.log('  ', chalk.magenta(stripNonAsciiChars(type).trim() + ':'));\n      entries.forEach((entry) => {\n        logger.log('    ', formatChangelogEntry(entry.message));\n      });\n    }\n  }\n}\n\n/**\n * Cuts off changelog for the new SDK and updates file with changelog versions.\n */\nasync function cutOffMainChangelogAsync(\n  mainChangelog: Changelog,\n  versions: ChangelogVersions,\n  nextVersion: string\n): Promise<void> {\n  logger.info(`\\n✂️  Cutting off changelog for SDK ${chalk.cyan(nextVersion)}...`);\n\n  await mainChangelog.cutOffAsync(nextVersion, [\n    ChangeType.LIBRARY_UPGRADES,\n    ChangeType.BREAKING_CHANGES,\n    ChangeType.NEW_FEATURES,\n    ChangeType.BUG_FIXES,\n  ]);\n\n  logger.info('\\n💾 Saving new changelog versions...');\n\n  // Create a new versions object with keys in descending order.\n  const newVersions = Object.keys(versions)\n    .sort((a, b) => sortVersionsAsc(b, a))\n    .reduce((acc, version) => {\n      acc[version] = versions[version];\n      return acc;\n    }, {});\n\n  // Update `changelogVersions.json` with keys being sorted in descending order.\n  await JsonFile.writeAsync(VERSIONS_FILE_PATH, newVersions);\n}\n\n/**\n * Comparator that sorts versions in ascending order with unpublished version being the last.\n */\nfunction sortVersionsAsc(a: string, b: string): number {\n  return a === UNPUBLISHED_VERSION_NAME\n    ? 1\n    : b === UNPUBLISHED_VERSION_NAME\n    ? -1\n    : semver.compare(a, b);\n}\n\n/**\n * Prompts the user whether to make initial release of given package.\n */\nasync function promptToMakeInitialReleaseAsync(packageName: string): Promise<boolean> {\n  logger.log();\n  const { confirm } = await inquirer.prompt([\n    {\n      type: 'confirm',\n      name: 'confirm',\n      default: true,\n      prefix: '❔',\n      message: `${chalk.green(packageName)} wasn't bundled in SDK yet. Do you want to include it?`,\n    },\n  ]);\n  return confirm;\n}\n"]}