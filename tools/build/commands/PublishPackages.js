"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const jsondiffpatch = __importStar(require("jsondiffpatch"));
const path_1 = __importDefault(require("path"));
const Constants_1 = require("../Constants");
const Git_1 = __importDefault(require("../Git"));
const Logger_1 = __importDefault(require("../Logger"));
const TasksRunner_1 = require("../TasksRunner");
const constants_1 = require("../publish-packages/constants");
const helpers_1 = require("../publish-packages/helpers");
const Packages_1 = require("../Packages");
const checkPackagesIntegrity_1 = require("../publish-packages/tasks/checkPackagesIntegrity");
const grantTeamAccessToPackages_1 = require("../publish-packages/tasks/grantTeamAccessToPackages");
const listUnpublished_1 = require("../publish-packages/tasks/listUnpublished");
const prepareParcels_1 = require("../publish-packages/tasks/prepareParcels");
const publishPackagesPipeline_1 = require("../publish-packages/tasks/publishPackagesPipeline");
exports.default = (program) => {
    program
        .command('publish-packages [packageNames...]')
        .alias('pub-pkg', 'publish', 'pp')
        .option('-p, --prerelease [prereleaseIdentifier]', 'Publish packages as prerelease versions. Prerelease identifier can be customized, defaults to `rc` if not provided.', false)
        .option('-t, --tag <tag>', 'Tag to pass to `npm publish` command. Defaults to `next`. Use `latest` only if you are sure to start distributing packages immediately.', 'next')
        .option('-r, --retry', `Retries previous command run using the backup saved before the task at which the process has stopped. Some other options and arguments must stay the same.`, false)
        .option('-m, --commit-message <commitMessage>', 'Customizes publish commit message. It is auto-generated by default.')
        /* exclusive options */
        .option('-l, --list-unpublished', 'Lists packages with unpublished changes since the previous version.', false)
        .option('-g, --grant-access', 'Grants organization team access to packages in which someone from the team is not included as package maintainer.', false)
        .option('-c, --check-integrity', 'Checks integrity of packages. These checks must pass to clearly identify changes that have been made since previous publish.', false)
        /* debug options */
        .option('-S, --skip-repo-checks', 'Skips checking whether the command is run on master branch and there are no unstaged changes.', false)
        .option('-D, --dry', 'Whether to skip pushing publish commit to remote repo and run `npm publish` in dry mode. Despite this, some files might be changed and committed.', false)
        .description(
    // prettier-ignore
    `This script publishes packages within the monorepo and takes care of bumping version numbers,
updating other workspace projects, committing and pushing changes to remote repo.

As it's prone to errors due to its complexity and the fact it sometimes may take some time, we made it stateful.
It's been splitted into a few tasks after each a backup is saved under ${chalk_1.default.magenta.bold(path_1.default.relative(Constants_1.EXPO_DIR, constants_1.BACKUP_PATH))} file
and all file changes they made are added to Git's index as part of the backup. Due to its stateful nature,
your local repo must be clear (without unstaged changes) and you shouldn't make any changes in the repo while the command is running.

In case of any errors or mistakes you can always go back to the previous phase by running the exact same command again,
but remember to leave staged changes as they were because they're also part of the backup.`)
        .usage(`

To list packages with unpublished changes:
${chalk_1.default.gray('>')} ${chalk_1.default.italic.cyan('et publish -l')}

To publish all packages with unpublished changes:
${chalk_1.default.gray('>')} ${chalk_1.default.italic.cyan('et publish')}

To publish just specific packages and their dependencies:
${chalk_1.default.gray('>')} ${chalk_1.default.italic.cyan('et publish expo-gl expo-auth-session')}`)
        .asyncAction(main);
};
/**
 * Main action of the command. Goes through appropriate tasks, based on command options.
 */
async function main(packageNames, options) {
    // Commander doesn't put arguments to options object, let's add it for convenience. In fact, this is an option.
    options.packageNames = packageNames;
    const tasks = tasksForOptions(options);
    const taskRunner = new TasksRunner_1.TaskRunner({
        tasks,
        backupFilePath: constants_1.BACKUP_PATH,
        backupExpirationTime: constants_1.BACKUP_EXPIRATION_TIME,
        /**
         * Backup is valid if current head commit hash is the same as from the time where the backup was saved,
         * and there is no difference in command options.
         */
        async validateBackup(backup) {
            const headCommitHash = await Git_1.default.getHeadCommitHashAsync();
            return (backup.data &&
                headCommitHash === backup.data.head &&
                !jsondiffpatch.diff(helpers_1.pickBackupableOptions(options), backup.data.options));
        },
        /**
         * At this point a backup is valid but we can discard it if `--retry` option wasn't provided.
         */
        async shouldUseBackup() {
            return await helpers_1.shouldUseBackupAsync(options);
        },
        /**
         * Provides backup data for task runner.
         */
        async createBackupData(task, parcels, options) {
            const data = {
                options: helpers_1.pickBackupableOptions(options),
                head: await Git_1.default.getHeadCommitHashAsync(),
                state: {},
            };
            for (const { pkg, state } of parcels) {
                data.state[pkg.packageName] = JSON.parse(JSON.stringify(state));
            }
            return data;
        },
        /**
         * Applies given backup to parcels array.
         */
        async restoreBackup(backup, parcels) {
            const dateString = new Date(backup.timestamp).toLocaleString();
            Logger_1.default.info(`♻️  Restoring from backup saved on ${chalk_1.default.magenta(dateString)}...`);
            const allPackages = await Packages_1.getListOfPackagesAsync();
            for (const [packageName, restoredState] of Object.entries(backup.data.state)) {
                const pkg = allPackages.find((pkg) => pkg.packageName === packageName);
                if (pkg) {
                    const parcel = await prepareParcels_1.createParcelAsync(pkg);
                    parcel.state = { ...parcel.state, ...restoredState };
                    parcels.push(parcel);
                }
            }
        },
        /**
         * Method that is called once existing backup is no longer valid.
         */
        backupValidationFailed() {
            Logger_1.default.warn(`⚠️  Found backup file but you've run the command with different options. Continuing from scratch...`);
        },
    });
    await taskRunner.runAndExitAsync([], options);
}
/**
 * Returns target task instances based on provided command options.
 */
function tasksForOptions(options) {
    if (options.listUnpublished) {
        return [listUnpublished_1.listUnpublished];
    }
    if (options.grantAccess) {
        return [grantTeamAccessToPackages_1.grantTeamAccessToPackages];
    }
    if (options.checkIntegrity) {
        return [prepareParcels_1.prepareParcels, checkPackagesIntegrity_1.checkPackagesIntegrity];
    }
    return [publishPackagesPipeline_1.publishPackagesPipeline];
}
//# sourceMappingURL=PublishPackages.js.map