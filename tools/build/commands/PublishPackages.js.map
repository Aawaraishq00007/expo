{"version":3,"file":"PublishPackages.js","sourceRoot":"","sources":["../../src/commands/PublishPackages.ts"],"names":[],"mappings":"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","sourcesContent":["import { Command } from '@expo/commander';\nimport chalk from 'chalk';\nimport * as jsondiffpatch from 'jsondiffpatch';\nimport path from 'path';\n\nimport { EXPO_DIR } from '../Constants';\nimport Git from '../Git';\nimport logger from '../Logger';\nimport { TaskRunner, Task, TasksRunnerBackup } from '../TasksRunner';\nimport { BACKUP_PATH, BACKUP_EXPIRATION_TIME } from '../publish-packages/constants';\nimport { pickBackupableOptions, shouldUseBackupAsync } from '../publish-packages/helpers';\nimport { CommandOptions, Parcel, TaskArgs, PublishBackupData } from '../publish-packages/types';\nimport { getListOfPackagesAsync } from '../Packages';\n\nimport { checkPackagesIntegrity } from '../publish-packages/tasks/checkPackagesIntegrity';\nimport { grantTeamAccessToPackages } from '../publish-packages/tasks/grantTeamAccessToPackages';\nimport { listUnpublished } from '../publish-packages/tasks/listUnpublished';\nimport { prepareParcels, createParcelAsync } from '../publish-packages/tasks/prepareParcels';\nimport { publishPackagesPipeline } from '../publish-packages/tasks/publishPackagesPipeline';\n\nexport default (program: Command) => {\n  program\n    .command('publish-packages [packageNames...]')\n    .alias('pub-pkg', 'publish', 'pp')\n    .option(\n      '-p, --prerelease [prereleaseIdentifier]',\n      'Publish packages as prerelease versions. Prerelease identifier can be customized, defaults to `rc` if not provided.',\n      false\n    )\n    .option(\n      '-t, --tag <tag>',\n      'Tag to pass to `npm publish` command. Defaults to `next`. Use `latest` only if you are sure to start distributing packages immediately.',\n      'next'\n    )\n    .option(\n      '-r, --retry',\n      `Retries previous command run using the backup saved before the task at which the process has stopped. Some other options and arguments must stay the same.`,\n      false\n    )\n    .option(\n      '-m, --commit-message <commitMessage>',\n      'Customizes publish commit message. It is auto-generated by default.'\n    )\n\n    /* exclusive options */\n    .option(\n      '-l, --list-unpublished',\n      'Lists packages with unpublished changes since the previous version.',\n      false\n    )\n    .option(\n      '-g, --grant-access',\n      'Grants organization team access to packages in which someone from the team is not included as package maintainer.',\n      false\n    )\n    .option(\n      '-c, --check-integrity',\n      'Checks integrity of packages. These checks must pass to clearly identify changes that have been made since previous publish.',\n      false\n    )\n\n    /* debug options */\n    .option(\n      '-S, --skip-repo-checks',\n      'Skips checking whether the command is run on master branch and there are no unstaged changes.',\n      false\n    )\n    .option(\n      '-D, --dry',\n      'Whether to skip pushing publish commit to remote repo and run `npm publish` in dry mode. Despite this, some files might be changed and committed.',\n      false\n    )\n\n    .description(\n      // prettier-ignore\n      `This script publishes packages within the monorepo and takes care of bumping version numbers,\nupdating other workspace projects, committing and pushing changes to remote repo.\n\nAs it's prone to errors due to its complexity and the fact it sometimes may take some time, we made it stateful.\nIt's been splitted into a few tasks after each a backup is saved under ${chalk.magenta.bold(path.relative(EXPO_DIR, BACKUP_PATH))} file\nand all file changes they made are added to Git's index as part of the backup. Due to its stateful nature,\nyour local repo must be clear (without unstaged changes) and you shouldn't make any changes in the repo while the command is running.\n\nIn case of any errors or mistakes you can always go back to the previous phase by running the exact same command again,\nbut remember to leave staged changes as they were because they're also part of the backup.`\n    )\n    .usage(\n      `\n\nTo list packages with unpublished changes:\n${chalk.gray('>')} ${chalk.italic.cyan('et publish -l')}\n\nTo publish all packages with unpublished changes:\n${chalk.gray('>')} ${chalk.italic.cyan('et publish')}\n\nTo publish just specific packages and their dependencies:\n${chalk.gray('>')} ${chalk.italic.cyan('et publish expo-gl expo-auth-session')}`\n    )\n    .asyncAction(main);\n};\n\n/**\n * Main action of the command. Goes through appropriate tasks, based on command options.\n */\nasync function main(packageNames: string[], options: CommandOptions): Promise<void> {\n  // Commander doesn't put arguments to options object, let's add it for convenience. In fact, this is an option.\n  options.packageNames = packageNames;\n\n  const tasks = tasksForOptions(options);\n  const taskRunner = new TaskRunner<TaskArgs, PublishBackupData>({\n    tasks,\n    backupFilePath: BACKUP_PATH,\n    backupExpirationTime: BACKUP_EXPIRATION_TIME,\n\n    /**\n     * Backup is valid if current head commit hash is the same as from the time where the backup was saved,\n     * and there is no difference in command options.\n     */\n    async validateBackup(backup): Promise<boolean> {\n      const headCommitHash = await Git.getHeadCommitHashAsync();\n\n      return (\n        backup.data &&\n        headCommitHash === backup.data.head &&\n        !jsondiffpatch.diff(pickBackupableOptions(options), backup.data.options)\n      );\n    },\n\n    /**\n     * At this point a backup is valid but we can discard it if `--retry` option wasn't provided.\n     */\n    async shouldUseBackup(): Promise<boolean> {\n      return await shouldUseBackupAsync(options);\n    },\n\n    /**\n     * Provides backup data for task runner.\n     */\n    async createBackupData(task, parcels, options): Promise<PublishBackupData> {\n      const data = {\n        options: pickBackupableOptions(options),\n        head: await Git.getHeadCommitHashAsync(),\n        state: {},\n      };\n\n      for (const { pkg, state } of parcels) {\n        data.state[pkg.packageName] = JSON.parse(JSON.stringify(state));\n      }\n      return data;\n    },\n\n    /**\n     * Applies given backup to parcels array.\n     */\n    async restoreBackup(\n      backup: TasksRunnerBackup<PublishBackupData>,\n      parcels: Parcel[]\n    ): Promise<void> {\n      const dateString = new Date(backup.timestamp).toLocaleString();\n\n      logger.info(`♻️  Restoring from backup saved on ${chalk.magenta(dateString)}...`);\n\n      const allPackages = await getListOfPackagesAsync();\n\n      for (const [packageName, restoredState] of Object.entries(backup.data!.state)) {\n        const pkg = allPackages.find((pkg) => pkg.packageName === packageName);\n\n        if (pkg) {\n          const parcel = await createParcelAsync(pkg);\n          parcel.state = { ...parcel.state, ...restoredState };\n          parcels.push(parcel);\n        }\n      }\n    },\n\n    /**\n     * Method that is called once existing backup is no longer valid.\n     */\n    backupValidationFailed() {\n      logger.warn(\n        `⚠️  Found backup file but you've run the command with different options. Continuing from scratch...`\n      );\n    },\n  });\n\n  await taskRunner.runAndExitAsync([], options);\n}\n\n/**\n * Returns target task instances based on provided command options.\n */\nfunction tasksForOptions(options: CommandOptions): Task<TaskArgs>[] {\n  if (options.listUnpublished) {\n    return [listUnpublished];\n  }\n  if (options.grantAccess) {\n    return [grantTeamAccessToPackages];\n  }\n  if (options.checkIntegrity) {\n    return [prepareParcels, checkPackagesIntegrity];\n  }\n  return [publishPackagesPipeline];\n}\n"]}