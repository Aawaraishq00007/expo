{"version":3,"file":"GitHubActions.js","sourceRoot":"","sources":["../src/GitHubActions.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ActionsListRepoWorkflowsResponseData,\n  ActionsListWorkflowRunsForRepoResponseData,\n  ActionsListJobsForWorkflowRunResponseData,\n  PullsGetResponseData,\n  IssuesCreateCommentResponseData,\n} from '@octokit/types';\nimport { request } from '@octokit/request';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { execAll, filterAsync } from './Utils';\nimport { EXPO_DIR } from './Constants';\n\nexport type Workflow = ActionsListRepoWorkflowsResponseData['workflows'][0] & {\n  slug: string;\n  baseSlug: string;\n  inputs?: Record<string, string>;\n};\nexport type WorkflowRun = ActionsListWorkflowRunsForRepoResponseData['workflow_runs'][0];\nexport type WorkflowDispatchEventInputs = Record<string, string>;\nexport type Job = ActionsListJobsForWorkflowRunResponseData['jobs'][0];\n\n/**\n * Requests for the list of active workflows.\n */\nexport async function getWorkflowsAsync(): Promise<Workflow[]> {\n  const response = await request('GET /repos/:owner/:repo/actions/workflows', makeExpoOptions({}));\n\n  // We need to filter out some workflows because they might have\n  // - empty `name` or `path` (why?)\n  // - inactive state\n  // - workflow config no longer exists\n  const workflows = await filterAsync(response.data.workflows, async (workflow) =>\n    Boolean(\n      workflow.name &&\n        workflow.path &&\n        workflow.state === 'active' &&\n        (await fs.pathExists(path.join(EXPO_DIR, workflow.path)))\n    )\n  );\n  return workflows\n    .sort((a, b) => a.name.localeCompare(b.name))\n    .map((workflow) => {\n      const slug = path.basename(workflow.path, path.extname(workflow.path));\n      return {\n        ...workflow,\n        slug,\n        baseSlug: slug,\n      };\n    });\n}\n\n/**\n * Requests for the list of manually triggered runs for given workflow ID.\n */\nexport async function getWorkflowRunsAsync(\n  workflowId: number,\n  event?: string\n): Promise<WorkflowRun[]> {\n  const response = await request(\n    'GET /repos/:owner/:repo/actions/runs',\n    makeExpoOptions({ event })\n  );\n  return response.data.workflow_runs.filter(\n    (workflowRun) => workflowRun.workflow_id === workflowId\n  );\n}\n\n/**\n * Resolves to the recently dispatched workflow run.\n */\nexport async function getLatestDispatchedWorkflowRunAsync(\n  workflowId: number\n): Promise<WorkflowRun | null> {\n  const workflowRuns = await getWorkflowRunsAsync(workflowId, 'workflow_dispatch');\n  return workflowRuns[0] ?? null;\n}\n\n/**\n * Requests for the list of job for workflow run with given ID.\n */\nexport async function getJobsForWorkflowRunAsync(workflowRunId: number): Promise<Job[]> {\n  const response = await request(\n    'GET /repos/:owner/:repo/actions/runs/:run_id/jobs',\n    makeExpoOptions({\n      run_id: workflowRunId,\n    })\n  );\n  return response.data.jobs;\n}\n\n/**\n * Dispatches an event that triggers a workflow with given ID or workflow filename (including extension).\n */\nexport async function dispatchWorkflowEventAsync(\n  workflowId: number | string,\n  ref: string,\n  inputs?: WorkflowDispatchEventInputs\n): Promise<void> {\n  await request(\n    'POST /repos/:owner/:repo/actions/workflows/:workflow_id/dispatches',\n    // @ts-ignore It expects workflow_id to be a number, however workflow filename (string) is also supported.\n    makeExpoOptions({\n      workflow_id: workflowId,\n      ref,\n      inputs: inputs ?? {},\n    })\n  );\n}\n\n/**\n * Requests for the pull request object.\n */\nexport async function getPullRequestAsync(pullRequestId: number): Promise<PullsGetResponseData> {\n  const response = await request(\n    'GET /repos/:owner/:repo/pulls/:pull_number',\n    makeExpoOptions({\n      pull_number: pullRequestId, //10469,\n    })\n  );\n  return response.data;\n}\n\n/**\n * Returns an array of issue IDs that has been auto-closed by the pull request.\n */\nexport async function getClosedIssuesAsync(pullRequestId: number): Promise<number[]> {\n  const pullRequest = await getPullRequestAsync(pullRequestId);\n  const matches = execAll(\n    /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved) (#|https:\\/\\/github\\.com\\/expo\\/expo\\/issues\\/)(\\d+)/gi,\n    pullRequest.body,\n    2\n  );\n  return matches.map((match) => parseInt(match, 10)).filter((issue) => !isNaN(issue));\n}\n\n/**\n * Creates an issue comment with given body.\n */\nexport async function commentOnIssueAsync(\n  issueId: number,\n  body: string\n): Promise<IssuesCreateCommentResponseData> {\n  const response = await request(\n    'POST /repos/:owner/:repo/issues/:issue_number/comments',\n    makeExpoOptions({\n      issue_number: issueId,\n      body,\n    })\n  );\n  return response.data;\n}\n\n/**\n * Copies given object with params specific for `expo/expo` repository and with authorization token.\n */\nfunction makeExpoOptions<T>(\n  options: T & { headers?: object }\n): T & { owner: string; repo: string } {\n  return {\n    headers: {\n      authorization: `token ${process.env.GITHUB_TOKEN}`,\n      ...options?.headers,\n    },\n    owner: 'expo',\n    repo: 'expo',\n    ...options,\n  };\n}\n"]}